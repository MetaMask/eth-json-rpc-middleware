{"version":3,"file":"wallet.js","sourceRoot":"","sources":["../src/wallet.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  createAsyncMiddleware,\n  createScaffoldMiddleware,\n  JsonRpcMiddleware,\n  JsonRpcRequest,\n  PendingJsonRpcResponse,\n} from 'json-rpc-engine';\nimport * as sigUtil from 'eth-sig-util';\nimport { ethErrors } from 'eth-rpc-errors';\nimport type { Block } from './types';\n\nexport interface TransactionParams {\n  from: string;\n}\n\nexport interface MessageParams extends TransactionParams {\n  data: string;\n}\n\ninterface TypedMessageParams extends MessageParams {\n  version: string;\n}\ninterface WalletMiddlewareOptions {\n  getAccounts: (\n    req: JsonRpcRequest<unknown>,\n    options?: {\n      suppressUnauthorized?: boolean;\n    },\n  ) => Promise<string[]>;\n  processDecryptMessage?: (\n    msgParams: MessageParams,\n    req: JsonRpcRequest<unknown>,\n  ) => Promise<Record<string, unknown>>;\n  processEncryptionPublicKey?: (\n    address: string,\n    req: JsonRpcRequest<unknown>,\n  ) => Promise<Record<string, unknown>>;\n  processEthSignMessage?: (\n    msgParams: MessageParams,\n    req: JsonRpcRequest<unknown>,\n  ) => Promise<Record<string, unknown>>;\n  processPersonalMessage?: (\n    msgParams: MessageParams,\n    req: JsonRpcRequest<unknown>,\n  ) => Promise<string>;\n  processTransaction?: (\n    txParams: TransactionParams,\n    req: JsonRpcRequest<unknown>,\n  ) => Promise<string>;\n  processSignTransaction?: (\n    txParams: TransactionParams,\n    req: JsonRpcRequest<unknown>,\n  ) => Promise<string>;\n  processTypedMessage?: (\n    msgParams: MessageParams,\n    req: JsonRpcRequest<unknown>,\n    version: string,\n  ) => Promise<string>;\n  processTypedMessageV3?: (\n    msgParams: TypedMessageParams,\n    req: JsonRpcRequest<unknown>,\n    version: string,\n  ) => Promise<Record<string, unknown>>;\n  processTypedMessageV4?: (\n    msgParams: TypedMessageParams,\n    req: JsonRpcRequest<unknown>,\n    version: string,\n  ) => Promise<Record<string, unknown>>;\n}\n\nexport function createWalletMiddleware({\n  getAccounts,\n  processDecryptMessage,\n  processEncryptionPublicKey,\n  processEthSignMessage,\n  processPersonalMessage,\n  processTransaction,\n  processSignTransaction,\n  processTypedMessage,\n  processTypedMessageV3,\n  processTypedMessageV4,\n}: WalletMiddlewareOptions): JsonRpcMiddleware<string, Block> {\n  if (!getAccounts) {\n    throw new Error('opts.getAccounts is required');\n  }\n\n  return createScaffoldMiddleware({\n    // account lookups\n    eth_accounts: createAsyncMiddleware(lookupAccounts),\n    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),\n    // tx signatures\n    eth_sendTransaction: createAsyncMiddleware(sendTransaction),\n    eth_signTransaction: createAsyncMiddleware(signTransaction),\n    // message signatures\n    eth_sign: createAsyncMiddleware(ethSign),\n    eth_signTypedData: createAsyncMiddleware(signTypedData),\n    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),\n    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),\n    personal_sign: createAsyncMiddleware(personalSign),\n    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),\n    eth_decrypt: createAsyncMiddleware(decryptMessage),\n    personal_ecRecover: createAsyncMiddleware(personalRecover),\n  });\n\n  //\n  // account lookups\n  //\n\n  async function lookupAccounts(\n    req: JsonRpcRequest<unknown>,\n    res: PendingJsonRpcResponse<unknown>,\n  ): Promise<void> {\n    res.result = await getAccounts(req);\n  }\n\n  async function lookupDefaultAccount(\n    req: JsonRpcRequest<unknown>,\n    res: PendingJsonRpcResponse<unknown>,\n  ): Promise<void> {\n    const accounts = await getAccounts(req);\n    res.result = accounts[0] || null;\n  }\n\n  //\n  // transaction signatures\n  //\n\n  async function sendTransaction(\n    req: JsonRpcRequest<unknown>,\n    res: PendingJsonRpcResponse<unknown>,\n  ): Promise<void> {\n    if (!processTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams: TransactionParams =\n      (req.params as TransactionParams[])[0] || {};\n    txParams.from = await validateAndNormalizeKeyholder(\n      txParams.from as string,\n      req,\n    );\n    res.result = await processTransaction(txParams, req);\n  }\n\n  async function signTransaction(\n    req: JsonRpcRequest<unknown>,\n    res: PendingJsonRpcResponse<unknown>,\n  ): Promise<void> {\n    if (!processSignTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams: TransactionParams =\n      (req.params as TransactionParams[])[0] || {};\n    txParams.from = await validateAndNormalizeKeyholder(\n      txParams.from as string,\n      req,\n    );\n    res.result = await processSignTransaction(txParams, req);\n  }\n\n  //\n  // message signatures\n  //\n\n  async function ethSign(\n    req: JsonRpcRequest<unknown>,\n    res: PendingJsonRpcResponse<unknown>,\n  ): Promise<void> {\n    if (!processEthSignMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address: string = await validateAndNormalizeKeyholder(\n      (req.params as string[])[0],\n      req,\n    );\n    const message: string = (req.params as string[])[1];\n    const extraParams: Record<string, unknown> =\n      (req.params as Record<string, unknown>[])[2] || {};\n    const msgParams: MessageParams = {\n      ...extraParams,\n      from: address,\n      data: message,\n    };\n\n    res.result = await processEthSignMessage(msgParams, req);\n  }\n\n  async function signTypedData(\n    req: JsonRpcRequest<unknown>,\n    res: PendingJsonRpcResponse<unknown>,\n  ): Promise<void> {\n    if (!processTypedMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const message: string = (req.params as string[])[0];\n    const address: string = await validateAndNormalizeKeyholder(\n      (req.params as string[])[1],\n      req,\n    );\n    const version = 'V1';\n    const extraParams: Record<string, unknown> =\n      (req.params as Record<string, unknown>[])[2] || {};\n    const msgParams: MessageParams = {\n      ...extraParams,\n      from: address,\n      data: message,\n    };\n\n    res.result = await processTypedMessage(msgParams, req, version);\n  }\n\n  async function signTypedDataV3(\n    req: JsonRpcRequest<unknown>,\n    res: PendingJsonRpcResponse<unknown>,\n  ): Promise<void> {\n    if (!processTypedMessageV3) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address: string = await validateAndNormalizeKeyholder(\n      (req.params as string[])[0],\n      req,\n    );\n    const message: string = (req.params as string[])[1];\n    const version = 'V3';\n    const msgParams: TypedMessageParams = {\n      data: message,\n      from: address,\n      version,\n    };\n\n    res.result = await processTypedMessageV3(msgParams, req, version);\n  }\n\n  async function signTypedDataV4(\n    req: JsonRpcRequest<unknown>,\n    res: PendingJsonRpcResponse<unknown>,\n  ): Promise<void> {\n    if (!processTypedMessageV4) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address: string = await validateAndNormalizeKeyholder(\n      (req.params as string[])[0],\n      req,\n    );\n    const message: string = (req.params as string)[1];\n    const version = 'V4';\n    const msgParams: TypedMessageParams = {\n      data: message,\n      from: address,\n      version,\n    };\n\n    res.result = await processTypedMessageV4(msgParams, req, version);\n  }\n\n  async function personalSign(\n    req: JsonRpcRequest<unknown>,\n    res: PendingJsonRpcResponse<unknown>,\n  ): Promise<void> {\n    if (!processPersonalMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    // process normally\n    const firstParam: string = (req.params as string[])[0];\n    const secondParam: string = (req.params as string[])[1];\n    // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n    const extraParams: Record<string, unknown> =\n      (req.params as Record<string, unknown>[])[2] || {};\n\n    // We initially incorrectly ordered these parameters.\n    // To gracefully respect users who adopted this API early,\n    // we are currently gracefully recovering from the wrong param order\n    // when it is clearly identifiable.\n    //\n    // That means when the first param is definitely an address,\n    // and the second param is definitely not, but is hex.\n    let address: string, message: string;\n    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {\n      let warning = `The eth_personalSign method requires params ordered `;\n      warning += `[message, address]. This was previously handled incorrectly, `;\n      warning += `and has been corrected automatically. `;\n      warning += `Please switch this param order for smooth behavior in the future.`;\n      (res as any).warning = warning;\n\n      address = firstParam;\n      message = secondParam;\n    } else {\n      message = firstParam;\n      address = secondParam;\n    }\n    address = await validateAndNormalizeKeyholder(address, req);\n\n    const msgParams: MessageParams = {\n      ...extraParams,\n      from: address,\n      data: message,\n    };\n\n    // eslint-disable-next-line require-atomic-updates\n    res.result = await processPersonalMessage(msgParams, req);\n  }\n\n  async function personalRecover(\n    req: JsonRpcRequest<unknown>,\n    res: PendingJsonRpcResponse<unknown>,\n  ): Promise<void> {\n    const message: string = (req.params as string)[0];\n    const signature: string = (req.params as string)[1];\n    const extraParams: Record<string, unknown> =\n      (req.params as Record<string, unknown>[])[2] || {};\n    const msgParams: sigUtil.SignedMessageData<unknown> = {\n      ...extraParams,\n      sig: signature,\n      data: message,\n    };\n    const signerAddress: string = sigUtil.recoverPersonalSignature(msgParams);\n\n    res.result = signerAddress;\n  }\n\n  async function encryptionPublicKey(\n    req: JsonRpcRequest<unknown>,\n    res: PendingJsonRpcResponse<unknown>,\n  ): Promise<void> {\n    if (!processEncryptionPublicKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address: string = await validateAndNormalizeKeyholder(\n      (req.params as string)[0],\n      req,\n    );\n\n    res.result = await processEncryptionPublicKey(address, req);\n  }\n\n  async function decryptMessage(\n    req: JsonRpcRequest<unknown>,\n    res: PendingJsonRpcResponse<unknown>,\n  ): Promise<void> {\n    if (!processDecryptMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const ciphertext: string = (req.params as string)[0];\n    const address: string = await validateAndNormalizeKeyholder(\n      (req.params as string)[1],\n      req,\n    );\n    const extraParams: Record<string, unknown> =\n      (req.params as Record<string, unknown>[])[2] || {};\n    const msgParams: MessageParams = {\n      ...extraParams,\n      from: address,\n      data: ciphertext,\n    };\n\n    res.result = await processDecryptMessage(msgParams, req);\n  }\n\n  //\n  // utility\n  //\n\n  /**\n   * Validates the keyholder address, and returns a normalized (i.e. lowercase)\n   * copy of it.\n   *\n   * @param {string} address - The address to validate and normalize.\n   * @param {Object} req - The request object.\n   * @returns {string} - The normalized address, if valid. Otherwise, throws\n   * an error\n   */\n  async function validateAndNormalizeKeyholder(\n    address: string,\n    req: JsonRpcRequest<unknown>,\n  ): Promise<string> {\n    if (\n      typeof address === 'string' &&\n      address.length > 0 &&\n      resemblesAddress(address)\n    ) {\n      // ensure address is included in provided accounts. `suppressUnauthorized: false` is passed to `getAccounts`\n      // so that an \"unauthorized\" error is thrown if the requester does not have the `eth_accounts`\n      // permission.\n      const accounts: string[] = await getAccounts(req, {\n        suppressUnauthorized: false,\n      });\n      const normalizedAccounts: string[] = accounts.map((_address) =>\n        _address.toLowerCase(),\n      );\n      const normalizedAddress: string = address.toLowerCase();\n\n      if (normalizedAccounts.includes(normalizedAddress)) {\n        return normalizedAddress;\n      }\n      throw ethErrors.provider.unauthorized();\n    }\n    throw ethErrors.rpc.invalidParams({\n      message: `Invalid parameters: must provide an Ethereum address.`,\n    });\n  }\n}\n\nfunction resemblesAddress(str: string): boolean {\n  // hex prefix 2 + 20 bytes\n  return str.length === 2 + 20 * 2;\n}\n"]}