{"version":3,"file":"inflight-cache.js","sourceRoot":"","sources":["../src/inflight-cache.ts"],"names":[],"mappings":";;;;;;AAAA,kDAA0B;AAC1B,qDAIyB;AACzB,yCAA0D;AAQ1D,SAAgB,6BAA6B;IAI3C,MAAM,gBAAgB,GAAoB,EAAE,CAAC;IAE7C,OAAO,IAAA,uCAAqB,EAAC,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE;QACpD,2CAA2C;QAC3C,IAAK,GAA6B,CAAC,SAAS,EAAE;YAC5C,OAAO,IAAI,EAAE,CAAC;SACf;QACD,4BAA4B;QAC5B,MAAM,OAAO,GAAkB,IAAA,iCAAyB,EAAC,GAAG,CAAC,CAAC;QAC9D,yBAAyB;QACzB,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,IAAI,EAAE,CAAC;SACf;QACD,8BAA8B;QAC9B,IAAI,qBAAqB,GAAsB,gBAAgB,CAAC,OAAO,CAAC,CAAC;QACzE,sDAAsD;QACtD,IAAI,qBAAqB,EAAE;YACzB,2DAA2D;YAC3D,uDAAuD;YACvD,MAAM,0BAA0B,CAAC,GAAG,EAAE,qBAAqB,CAAC,CAAC;YAC7D,OAAO,SAAS,CAAC;SAClB;QACD,uDAAuD;QACvD,qBAAqB,GAAG,EAAE,CAAC;QAC3B,gBAAgB,CAAC,OAAO,CAAC,GAAG,qBAAqB,CAAC;QAClD,uCAAuC;QACvC,gDAAgD;QAChD,MAAM,IAAI,EAAE,CAAC;QACb,0BAA0B;QAC1B,OAAO,gBAAgB,CAAC,OAAO,CAAC,CAAC;QACjC,+CAA+C;QAC/C,mBAAmB,CAAC,GAAG,EAAE,qBAAqB,CAAC,CAAC;QAChD,WAAW;QACX,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC,CAAC;IAEH,SAAS,0BAA0B,CACjC,GAAkC,EAClC,qBAAwC;QAExC,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,eAAe,EAAE,CAAC;QAC/C,qBAAqB,CAAC,IAAI,CAAC,CAAC,UAAyC,EAAE,EAAE;YACvE,wDAAwD;YACxD,GAAG,CAAC,MAAM,GAAG,IAAA,eAAK,EAAC,UAAU,CAAC,MAAM,CAAC,CAAC;YACtC,GAAG,CAAC,KAAK,GAAG,IAAA,eAAK,EAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YACpC,OAAO,EAAE,CAAC;QACZ,CAAC,CAAC,CAAC;QACH,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,SAAS,mBAAmB,CAC1B,GAAkC,EAClC,qBAAwC;QAExC,8DAA8D;QAC9D,UAAU,CAAC,GAAG,EAAE;YACd,qBAAqB,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;gBACxC,IAAI;oBACF,OAAO,CAAC,GAAG,CAAC,CAAC;iBACd;gBAAC,OAAO,GAAG,EAAE;oBACZ,oDAAoD;oBACpD,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;iBACpB;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;AACH,CAAC;AAtED,sEAsEC;AAED,SAAS,eAAe;IACtB,IAAI,OAAY,CAAC;IACjB,MAAM,OAAO,GAAkB,IAAI,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE;QACtD,OAAO,GAAG,QAAQ,CAAC;IACrB,CAAC,CAAC,CAAC;IACH,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC;AAC9B,CAAC","sourcesContent":["import clone from 'clone';\nimport {\n  createAsyncMiddleware,\n  JsonRpcMiddleware,\n  PendingJsonRpcResponse,\n} from 'json-rpc-engine';\nimport { cacheIdentifierForPayload } from './utils/cache';\nimport type { Block, JsonRpcRequestToCache } from './types';\n\ntype RequestHandlers = (handledRes: PendingJsonRpcResponse<Block>) => void;\ninterface InflightRequest {\n  [cacheId: string]: RequestHandlers[];\n}\n\nexport function createInflightCacheMiddleware(): JsonRpcMiddleware<\n  string[],\n  Block\n> {\n  const inflightRequests: InflightRequest = {};\n\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if ((req as JsonRpcRequestToCache).skipCache) {\n      return next();\n    }\n    // get cacheId, if cacheable\n    const cacheId: string | null = cacheIdentifierForPayload(req);\n    // if not cacheable, skip\n    if (!cacheId) {\n      return next();\n    }\n    // check for matching requests\n    let activeRequestHandlers: RequestHandlers[] = inflightRequests[cacheId];\n    // if found, wait for the active request to be handled\n    if (activeRequestHandlers) {\n      // setup the response listener and wait for it to be called\n      // it will handle copying the result and request fields\n      await createActiveRequestHandler(res, activeRequestHandlers);\n      return undefined;\n    }\n    // setup response handler array for subsequent requests\n    activeRequestHandlers = [];\n    inflightRequests[cacheId] = activeRequestHandlers;\n    // allow request to be handled normally\n    // eslint-disable-next-line node/callback-return\n    await next();\n    // clear inflight requests\n    delete inflightRequests[cacheId];\n    // schedule activeRequestHandlers to be handled\n    handleActiveRequest(res, activeRequestHandlers);\n    // complete\n    return undefined;\n  });\n\n  function createActiveRequestHandler(\n    res: PendingJsonRpcResponse<Block>,\n    activeRequestHandlers: RequestHandlers[],\n  ): Promise<void> {\n    const { resolve, promise } = deferredPromise();\n    activeRequestHandlers.push((handledRes: PendingJsonRpcResponse<Block>) => {\n      // append a copy of the result and error to the response\n      res.result = clone(handledRes.result);\n      res.error = clone(handledRes.error);\n      resolve();\n    });\n    return promise;\n  }\n\n  function handleActiveRequest(\n    res: PendingJsonRpcResponse<Block>,\n    activeRequestHandlers: RequestHandlers[],\n  ): void {\n    // use setTimeout so we can resolve our original request first\n    setTimeout(() => {\n      activeRequestHandlers.forEach((handler) => {\n        try {\n          handler(res);\n        } catch (err) {\n          // catch error so all requests are handled correctly\n          console.error(err);\n        }\n      });\n    });\n  }\n}\n\nfunction deferredPromise() {\n  let resolve: any;\n  const promise: Promise<void> = new Promise((_resolve) => {\n    resolve = _resolve;\n  });\n  return { resolve, promise };\n}\n"]}